/// タイミング追跡モジュール
///
/// エッジ間の時間を計測し、最大時間を追跡して同期パターンを検出する。
/// フレーム時間も計測してビットデコードの基準を提供。
///
/// # アルゴリズム
/// 1. エッジ間の時間をカウント
/// 2. 最大時間を追跡（遅い減衰付き）
/// 3. 最大時間の3/4を超えたら同期パターンと判定
/// 4. 同期→同期間の時間をフレーム時間として記録
///
/// # SYNC検出の原理
/// ADATのSYNCパターンは10個の連続'0'で、これはフレーム内で唯一の
/// 長時間無遷移期間（約814ns）となる。通常データは最大5ビット連続まで。
module timing_tracker (
    /// システムクロック
    i_clk: input clock,
    i_rst: input reset,
    /// エッジ検出パルス入力
    i_edge: input logic,
    /// 現在のエッジ間隔時間
    o_edge_time: output logic<12>,
    /// 同期検出フラグ (アクティブハイ=データ期間、ロー=同期期間)
    o_sync_detect: output logic,
    /// フレーム時間
    o_frame_time: output logic<12>,
) {
    // エッジ間時間カウンタ
    var cur_time: logic<12>;
    // 直前のエッジ間隔時間
    var edge_time: logic<12>;
    // 最大時間レジスタ (同期パターン検出用)
    var max_time: logic<10>;
    // 最大時間減衰用ウェイトカウンタ
    var wait_count: logic<16>;
    // 3/4閾値
    var threshold: logic<10>;
    // 同期マスク (1=データ期間、0=同期期間)
    var sync_mask: logic;
    // 同期マスクエッジ検出用
    var sync_ff: logic<2>;
    // フレーム時間カウンタ
    var frame_count: logic<12>;
    // 初回同期検出フラグ
    var have_prev_sync: logic;
    // フレーム時間レジスタ
    var frame_time: logic<12>;

    assign threshold     = (max_time >> 1) + (max_time >> 2); // 3/4 = 1/2 + 1/4
    assign o_edge_time   = edge_time;
    assign o_sync_detect = sync_mask;
    assign o_frame_time  = frame_time;

    // 遷移間時間カウンタと最大時間追跡
    always_ff {
        if_reset {
            cur_time   = 12'd0;
            edge_time  = 12'd0;
            max_time   = 10'd10; // 初期値: 40クロック/4 = 10 (cur_time[11:2], 50MHz)
            wait_count = 16'd0;
        } else if i_edge {
            // エッジでカウンタをリセット、最大値を更新
            edge_time = cur_time;
            if cur_time[11:2] >: max_time {
                max_time = cur_time[11:2];
            }
            cur_time = 12'd0;
        } else {
            cur_time = cur_time + 12'd1;
            // 徐々にmax_timeを減少（AGC的動作でジッタに対応）
            if wait_count == 16'hFFFF {
                if max_time >: 10'd1 {
                    max_time = max_time - 10'd1;
                }
                wait_count = 16'd0;
            } else {
                wait_count = wait_count + 16'd1;
            }
        }
    }

    // 同期検出: エッジ間隔が閾値以下ならデータ期間
    // エッジ到来時に判定し、次のエッジまで保持
    always_ff {
        if_reset {
            sync_mask = 1'b0;
        } else if i_edge {
            sync_mask = cur_time[11:2] <= threshold;
        }
    }

    // フレーム時間測定: sync_maskの立ち上がりでキャプチャ
    always_ff {
        if_reset {
            sync_ff        = 2'b00;
            frame_count    = 12'd0;
            frame_time     = 12'd1042;
            have_prev_sync = 1'b0;
        } else {
            sync_ff[1] = sync_ff[0];
            sync_ff[0] = sync_mask;
            // sync間隔(長いエッジ間隔)の終了時にフレーム時間をキャプチャ
            if i_edge && (cur_time[11:2] >: threshold) {
                if have_prev_sync {
                    frame_time = frame_count;
                } else {
                    have_prev_sync = 1'b1;
                }
                frame_count = 12'd0;
            } else {
                frame_count = frame_count + 12'd1;
            }
        }
    }
}

#[test(tb_timing_tracker)]
embed (inline) sv{{{
    module tb_timing_tracker;
        logic clk;
        logic rst;
        logic edge_pulse;
        logic [11:0] edge_time;
        logic sync_detect;
        logic [11:0] frame_time;

        initial begin
            clk = 0;
            forever #10 clk = ~clk;
        end

        adat_rx_timing_tracker u_dut (
            .i_clk(clk),
            .i_rst(rst),
            .i_edge(edge_pulse),
            .o_edge_time(edge_time),
            .o_sync_detect(sync_detect),
            .o_frame_time(frame_time)
        );

        int pass;

        task pulse_edge(input int gap_cycles);
            begin
                edge_pulse = 1'b0;
                repeat (gap_cycles) @(posedge clk);
                edge_pulse = 1'b1;
                @(posedge clk);
                edge_pulse = 1'b0;
            end
        endtask

        initial begin
            pass = 1;
            rst = 1'b0;
            edge_pulse = 1'b0;
            repeat (2) @(posedge clk);
            rst = 1'b1;
            repeat (2) @(posedge clk);

            pulse_edge(4);
            if (sync_detect !== 1'b1) begin
                $error("FAIL: sync_detect should be 1 for short interval");
                pass = 0;
            end

            pulse_edge(40);
            if (sync_detect !== 1'b0) begin
                $error("FAIL: sync_detect should be 0 for long interval");
                pass = 0;
            end

            // Negative test: recover after a long gap (must not wedge)
            pulse_edge(4);
            if (sync_detect !== 1'b1) begin
                $error("FAIL: sync_detect should recover to 1 after long interval");
                pass = 0;
            end

            if (pass) begin
                $display("*** TEST PASSED ***");
            end else begin
                $error("*** TEST FAILED ***");
            end

            #20;
            $finish;
        end
    endmodule
}}}
