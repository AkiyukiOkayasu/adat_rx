/// ADATフレームパーサ
///
/// ビット列からユーザーデータと8チャンネルのPCMデータを抽出する。
/// 30ビットエンコードから24ビットPCMに変換。
///
/// # フレーム構造 (256 bits)
/// ```
/// [Sync 10bit][1][User 4bit][1][Ch0 30bit][Ch1 30bit]...[Ch7 30bit]
/// ```
///
/// ビット位置 (終了位置):
/// - User: bit 15
/// - Ch0: bit 45
/// - Ch1: bit 75
/// - Ch2: bit 105
/// - Ch3: bit 135
/// - Ch4: bit 165
/// - Ch5: bit 195
/// - Ch6: bit 225
/// - Ch7: bit 255
///
/// # 30bit → 24bit 変換
/// 各チャンネルは6つの5bitニブルで構成:
/// - 各ニブル: [D3:D0][sync_bit]
/// - 24bit = D[23:20] | D[19:16] | D[15:12] | D[11:8] | D[7:4] | D[3:0]
///
/// ```wavedrom
/// {signal: [
///   {name: 'i_clk', wave: 'p.............................................'},
///   {name: 'i_sync', wave: '1....................................0........'},
///   {name: 'bit_counter', wave: 'x2.....3.....4.....5.....6.....7.....8.....9', data: ['0', '5', '35', '65', '95', '125', '155', '185', '215', '245']},
///   {name: 'Extract', wave: 'x.....3.....4.....5.....6.....7.....8.....9..', data: ['User', 'Ch0', 'Ch1', 'Ch2', 'Ch3', 'Ch4', 'Ch5', 'Ch6', 'Ch7']},
///   {name: 'o_channel', wave: 'x......2.....3.....4.....5.....6.....7.....8.', data: ['0', '1', '2', '3', '4', '5', '6', '7']},
///   {name: 'o_data_valid', wave: '0......10....10....10....10....10....10....10'},
///   {name: 'Extract24bit', wave: 'x......5.....5.....5.....5.....5.....5.....5.', data: ['bits', 'x8ch']}
/// ],
/// config: {hscale: 2},
/// head: {text: 'Frame Parser - 30bit to 24bit Extraction'}}
/// ```
pub module frame_parser (
    /// システムクロック
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// デコードされたビット列
    i_bits: input logic<5>,
    /// ビット数
    i_bit_count: input logic<3>,
    /// ビット有効
    i_valid: input logic,
    /// 同期マスク (1=データ期間)
    i_sync: input logic,
    /// ユーザーデータ出力 (4bit)
    o_user: output logic<4>,
    /// PCMデータ出力 (24bit)
    o_data: output logic<24>,
    /// チャンネル番号 (0-7)
    o_channel: output logic<3>,
    /// データ有効
    o_data_valid: output logic,
) {
    // フレーム内ビットカウンタ
    var bit_counter: logic<8>;
    // 30bitシフトレジスタ
    var shift_reg: logic<30>;
    // 次シフトレジスタ値
    var shift_next: logic<30>;
    // 出力レジスタ
    var r_user   : logic<4> ;
    var r_data   : logic<24>;
    var r_channel: logic<3> ;
    var r_valid  : logic    ;

    assign o_user       = r_user;
    assign o_data       = r_data;
    assign o_channel    = r_channel;
    assign o_data_valid = r_valid;

    // 次シフト値（i_bit_countに応じてLSB側に追加）
    always_comb {
        shift_next = shift_reg;
        case i_bit_count {
            3'd1   : shift_next = {shift_reg[28:0], i_bits[0]};
            3'd2   : shift_next = {shift_reg[27:0], i_bits[0], i_bits[1]};
            3'd3   : shift_next = {shift_reg[26:0], i_bits[0], i_bits[1], i_bits[2]};
            3'd4   : shift_next = {shift_reg[25:0], i_bits[0], i_bits[1], i_bits[2], i_bits[3]};
            3'd5   : shift_next = {shift_reg[24:0], i_bits[0], i_bits[1], i_bits[2], i_bits[3], i_bits[4]};
            default: {}
        }
    }

    always_ff (i_clk, i_rst) {
        if_reset {
            bit_counter = 8'd0;
            shift_reg   = 30'd0;
            r_user      = 4'd0;
            r_data      = 24'd0;
            r_channel   = 3'd0;
            r_valid     = 1'b0;
        } else if !i_sync {
            // 同期期間: カウンタリセット
            bit_counter = 8'd0;
            shift_reg   = 30'd0;
            r_valid     = 1'b0;
        } else if i_valid {
            // ビットをシフトレジスタに追加
            shift_reg   = shift_next;
            let next_count : logic<8> = bit_counter + {5'd0, i_bit_count};
            bit_counter = next_count;

            // 各位置でデータ抽出
            // フレーム構造: [Sync 10bit][1][User 4bit][1][Ch0 30bit]...[Ch7 30bit]
            // 本実装は同期期間をフレーム境界として扱い、Sync 10bitはカウントしない
            // ユーザーデータ終了: 1 + 4 = bit 5
            // チャンネル終了位置: 5 + 30*n (Ch0: 35, Ch1: 65, Ch2: 95, etc.)
            if bit_counter <: 8'd5 && next_count >: 8'd4 {
                // ユーザーデータ: bits 1-4 (ビット順を反転)
                r_user  = {shift_next[0], shift_next[1], shift_next[2], shift_next[3]};
                r_valid = 1'b0;
            } else if bit_counter <: 8'd35 && next_count >: 8'd34 {
                // 30bit -> 24bit: 各5bitのnibbleから上位4bitを抽出。LSBは同期用セパレーターのため破棄。
                // shift_reg[29:26], [24:21], [19:16], [14:11], [9:6], [4:1]
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd0;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd65 && next_count >: 8'd64 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd1;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd95 && next_count >: 8'd94 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd2;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd125 && next_count >: 8'd124 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd3;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd155 && next_count >: 8'd154 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd4;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd185 && next_count >: 8'd184 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd5;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd215 && next_count >: 8'd214 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd6;
                r_valid   = 1'b1;
            } else if bit_counter <: 8'd245 && next_count >: 8'd244 {
                r_data    = {shift_next[29:26], shift_next[24:21], shift_next[19:16], shift_next[14:11], shift_next[9:6], shift_next[4:1]};
                r_channel = 3'd7;
                r_valid   = 1'b1;
            } else {
                r_valid = 1'b0;
            }
        } else {
            r_valid = 1'b0;
        }
    }
}
