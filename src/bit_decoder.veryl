/// NRZIビットデコーダ
///
/// 遷移間の時間から1〜5ビットをデコードする。
/// 時間ビニング方式を採用。
///
/// # NRZIエンコーディング
/// - 遷移あり = '1'ビット
/// - 遷移なし = '0'ビット
/// - 最大5ビット連続（4データビット + 1同期ビット）
///
/// # 時間ビン
/// - 0.5〜1.5 bit time → 1 bit ("1")
/// - 1.5〜2.5 bit time → 2 bits ("01")
/// - 2.5〜3.5 bit time → 3 bits ("001")
/// - 3.5〜4.5 bit time → 4 bits ("0001")
/// - 4.5〜5.5 bit time → 5 bits ("00001")
module bit_decoder (
    /// システムクロック
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// エッジ検出パルス
    i_edge: input logic,
    /// エッジ間隔時間
    i_edge_time: input logic<12>,
    /// フレーム時間
    i_frame_time: input logic<12>,
    /// 同期マスク (1=データ期間)
    i_sync_mask: input logic,
    /// デコードされたビット列 (LSB aligned)
    o_bits: output logic<5>,
    /// デコードされたビット数 (1-5)
    o_bit_count: output logic<3>,
    /// 出力有効
    o_valid: output logic,
) {
    // ビット時間 = フレーム時間 / 256
    var bit_time: logic<8>;
    // 出力レジスタ
    var r_bits : logic<5>;
    var r_count: logic<3>;
    var r_valid: logic   ;

    // bit_time = frame_time >> 8 (256で割る)
    // 最小値は常に十分な値になるはず
    assign bit_time = i_frame_time >> 8;

    assign o_bits      = r_bits;
    assign o_bit_count = r_count;
    assign o_valid     = r_valid;

    always_ff {
        if_reset {
            r_bits  = 5'b00000;
            r_count = 3'd0;
            r_valid = 1'b0;
        } else if i_edge && i_sync_mask {
            r_valid = 1'b1;
            // エッジ間隔をビット時間単位に変換
            let edge_bits: logic<8> = i_edge_time;
            // 閾値計算 (バイナリシフトで効率化)
            let t1: logic<8> = bit_time + (bit_time >> 1); // 1.5
            let t2: logic<8> = (bit_time << 1) + (bit_time >> 1); // 2.5
            let t3: logic<8> = (bit_time << 1) + bit_time + (bit_time >> 1); // 3.5
            let t4: logic<8> = (bit_time << 2) + (bit_time >> 1); // 4.5

            // 時間ビンによるビット数判定
            // NRZIデコード: 遷移で終わる→最後が'1'
            if edge_bits <= t1 {
                // 1 bit: "1"
                r_bits  = 5'b00001;
                r_count = 3'd1;
            } else if edge_bits <= t2 {
                // 2 bits: "01"
                r_bits  = 5'b00010;
                r_count = 3'd2;
            } else if edge_bits <= t3 {
                // 3 bits: "001"
                r_bits  = 5'b00100;
                r_count = 3'd3;
            } else if edge_bits <= t4 {
                // 4 bits: "0001"
                r_bits  = 5'b01000;
                r_count = 3'd4;
            } else {
                // 5 bits: "00001"
                r_bits  = 5'b10000;
                r_count = 3'd5;
            }
        } else if !i_sync_mask {
            // 同期期間中はリセット
            r_bits  = 5'b00000;
            r_count = 3'd0;
            r_valid = 1'b0;
        } else {
            r_valid = 1'b0;
        }
    }
}

#[test(tb_bit_decoder)]
embed (inline) sv{{{
module tb_bit_decoder;
  logic clk;
  logic rst;
  logic edge_pulse;
  logic [11:0] edge_time;
  logic [11:0] frame_time;
  logic sync_mask;
  logic [4:0] bits;
  logic [2:0] bit_count;
  logic valid;

  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  adat_rx_bit_decoder u_dut (
      .i_clk(clk),
      .i_rst(rst),
      .i_edge(edge_pulse),
      .i_edge_time(edge_time),
      .i_frame_time(frame_time),
      .i_sync_mask(sync_mask),
      .o_bits(bits),
      .o_bit_count(bit_count),
      .o_valid(valid)
  );

  task trigger_edge(input [11:0] interval);
    begin
      edge_time  = interval;
      edge_pulse = 1'b1;
      @(posedge clk);
      edge_pulse = 1'b0;
    end
  endtask

  int pass;

  initial begin
    pass = 1;
    rst = 1'b0;
    edge_pulse = 1'b0;
    edge_time = 12'd0;
    frame_time = 12'd2048;
    sync_mask = 1'b1;
    repeat (2) @(posedge clk);
    rst = 1'b1;
    repeat (2) @(posedge clk);

    trigger_edge(12'd1);
    if (!(valid && bit_count == 3'd1 && bits == 5'b00001)) begin
      $error("FAIL: 1-bit decode");
      pass = 0;
    end

    trigger_edge(12'd16);
    if (!(valid && bit_count == 3'd2 && bits == 5'b00010)) begin
      $error("FAIL: 2-bit decode");
      pass = 0;
    end

    trigger_edge(12'd40);
    if (!(valid && bit_count == 3'd5 && bits == 5'b10000)) begin
      $error("FAIL: 5-bit decode");
      pass = 0;
    end

    sync_mask = 1'b0;
    trigger_edge(12'd1);
    if (valid) begin
      $error("FAIL: valid should be 0 during sync");
      pass = 0;
    end

    if (pass) begin
      $display("*** TEST PASSED ***");
    end else begin
      $error("*** TEST FAILED ***");
    end

    #20;
    $finish;
  end
endmodule
}}}
