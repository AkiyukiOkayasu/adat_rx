import adat_pkg::*;

/// ADATレシーバ トップモジュール
///
/// ADAT光入力から8チャンネル24ビットPCMをデコードする。
/// クロックはADAT信号から自動復元される（外部PLLは不要）。
///
/// # 対応サンプルレート
/// - 48kHz: 8チャンネル
/// - 96kHz: 4チャンネル (S/MUX2)
/// - 192kHz: 2チャンネル (S/MUX4)
///
/// # ADATフレーム構造 (256 bits @ 48kHz = 20.83us)
///
/// 5ビットニブル単位で構成。各ニブル: [4bit data][1bit separator=1]
///
/// ```wavedrom
/// {signal: [
///   {name: 'BitIdx', wave: 'x2.....3.....4.....5.....6.....7.....8.....9.....2.....3.....4.....5.....',
///    data: ['0', '10', '16', '20', '25', '30', '35', '40', '45', '50', '55', '60', '65']},
///   {name: 'Field', wave: 'x6.....5.....4.....5.....5.....5.....5.....5.....5.....5.....5.....5.....',
///    data: ['SYNC(10b)', '1+U[3:0]', 'D0+1', 'D4+1', 'D8+1', 'D12+1', 'D16+1', 'D20+1', 'D0+1', 'D4+1', 'D8+1', 'D12+1', 'D16+1']},
///   {name: 'Separator', wave: 'x2.....2.....5.....5.....5.....5.....5.....5.....5.....5.....5.....5.....',
///    data: ['0..0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1']},
///   {name: 'Channel', wave: 'x6...........4..................................................5.........',
///    data: ['SYNC', 'CH0 (6 nibbles)', 'CH1']}
/// ],
/// config: {hscale: 4},
/// head: {text: 'ADAT Frame Detail: SYNC(10bits) + User(5bits) + CH0-7(30bits x8ch)'}}
/// ```
///
/// ## 詳細構成（5ビットニブル単位）
///
/// | ビット | 内容 | 説明 |
/// |--------|------|------|
/// | 0-9 | 0000000000 | SYNC: 10ビットの0（NRZIで無遷移） |
/// | 10-14 | 1 U3 U2 U1 U0 | User nibble: separator=1 + User bits[3:0] |
/// | 15-19 | D0-D3 + 1 | CH0 nibble0: audio[3:0] + separator |
/// | 20-24 | D4-D7 + 1 | CH0 nibble1: audio[7:4] + separator |
/// | 25-29 | D8-D11 + 1 | CH0 nibble2: audio[11:8] + separator |
/// | 30-34 | D12-D15 + 1 | CH0 nibble3: audio[15:12] + separator |
/// | 35-39 | D16-D19 + 1 | CH0 nibble4: audio[19:16] + separator |
/// | 40-44 | D20-D23 + 1 | CH0 nibble5: audio[23:20] + separator |
/// | 45-74 | ... | CH1 (上記と同じ6 nibbles) |
/// | ... | ... | CH2-CH7 (各30ビット) |
///
/// ## セパレーターの役割
/// - 各5ビットニブルの最後に「1」が配置される
/// - これによりNRZIエンコーディングで必ず遷移が発生
/// - 最大5ビット連続で無遷移になるのを防ぎ、同期を維持
///
/// # 使用例
/// ```veryl
/// inst adat: adat_rx (
///     i_clk     : sys_clk_100mhz,
///     i_rst     : reset,
///     i_adat    : toslink_in,
///     o_channels: audio_out,
///     o_word_clk: word_clk,
/// );
/// ```
///
/// # タイミング
/// - 推奨クロック: 100MHz
/// - ADAT入力: TOSLINK光→電気変換済み信号
pub module adat_rx (
    /// システムクロック (100MHz推奨)
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// ADAT入力 (光→電気変換済み)
    i_adat: input logic,
    /// ユーザーデータ出力 (4bit)
    o_user: output logic<4>,
    /// ワードクロック出力
    o_word_clk: output logic,
    /// 検出されたサンプルレート
    o_sample_rate: output SampleRate,
    /// 8チャンネルPCMデータ出力
    o_channels: output logic<24> [8],
    /// データ有効信号
    o_valid: output logic,
    /// 同期ロック状態
    o_locked: output logic,
    /// 有効なチャンネル数
    o_valid_channels: output logic<4>,
) {
    // 内部信号
    var adat_edge  : logic    ;
    var synced     : logic    ;
    var edge_time  : logic<12>;
    var max_time   : logic<10>;
    var sync_detect: logic    ;
    var frame_time : logic<12>;

    var bits      : logic<5> ;
    var bit_count : logic<3> ;
    var bits_valid: logic    ;
    var edge_delay: logic    ;
    var user_bits : logic<4> ;
    var pcm_data  : logic<24>;
    var channel   : logic<3> ;
    var data_valid: logic    ;

    // エッジ検出モジュール
    inst u_edge_detector: edge_detector (
        i_clk   : i_clk    ,
        i_rst   : i_rst    ,
        i_adat  : i_adat   ,
        o_edge  : adat_edge,
        o_synced: synced   ,
    );

    // タイミング追跡モジュール
    inst u_timing_tracker: timing_tracker (
        i_clk        : i_clk      ,
        i_rst        : i_rst      ,
        i_edge       : adat_edge  ,
        o_edge_time  : edge_time  ,
        o_max_time   : max_time   ,
        o_sync_detect: sync_detect,
        o_frame_time : frame_time ,
    );

    // ビットデコーダ入力を1サイクル遅延
    always_ff (i_clk, i_rst) {
        if_reset {
            edge_delay = 1'b0;
        } else {
            edge_delay = adat_edge;
        }
    }

    // ビットデコーダモジュール
    inst u_bit_decoder: bit_decoder (
        i_clk       : i_clk      ,
        i_rst       : i_rst      ,
        i_edge      : edge_delay ,
        i_edge_time : edge_time  ,
        i_frame_time: frame_time ,
        i_sync_mask : sync_detect,
        o_bits      : bits       ,
        o_bit_count : bit_count  ,
        o_valid     : bits_valid ,
    );

    // フレームパーサモジュール
    inst u_frame_parser: frame_parser (
        i_clk       : i_clk      ,
        i_rst       : i_rst      ,
        i_bits      : bits       ,
        i_bit_count : bit_count  ,
        i_valid     : bits_valid ,
        i_sync      : sync_detect,
        o_user      : user_bits  ,
        o_data      : pcm_data   ,
        o_channel   : channel    ,
        o_data_valid: data_valid ,
    );

    // 出力インターフェースモジュール
    inst u_output_interface: output_interface (
        i_clk           : i_clk           ,
        i_rst           : i_rst           ,
        i_frame_time    : frame_time      ,
        i_data          : pcm_data        ,
        i_channel       : channel         ,
        i_data_valid    : data_valid      ,
        i_sync          : sync_detect     ,
        i_user_bits     : user_bits       ,
        o_sample_rate   : o_sample_rate   ,
        o_word_clk      : o_word_clk      ,
        o_channels      : o_channels      ,
        o_valid         : o_valid         ,
        o_locked        : o_locked        ,
        o_valid_channels: o_valid_channels,
    );

    assign o_user = user_bits;
}
