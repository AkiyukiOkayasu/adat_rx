/// ADATレシーバ トップモジュール
///
/// ADAT光入力から8チャンネル24ビットPCMをデコードする。
/// クロックはADAT信号から自動復元される（外部PLLは不要）。
///
/// # 対応サンプルレート
/// - 48kHz: 8チャンネル
/// - 96kHz: 4チャンネル (S/MUX2)
/// - 192kHz: 2チャンネル (S/MUX4)
///
/// # ADATフレーム構造 (256 bits @ 48kHz = 20.83us)
///
/// 5ビットニブル単位で構成。各ニブル: [4bit data][1bit separator=1]
///
/// ## シリアル伝送順とビット有意性の定義
/// - シリアル伝送順: フレーム先頭から順方向（`build_frame[255]` → `build_frame[0]`）。
/// - 5bitニブルの伝送順: `D23..D20` のように data部は MSB-first。
/// - PCM 24bit語のビット有意性: `o_channels[x][23]` がMSB、`o_channels[x][0]` がLSB。
/// - したがって nibble 列 `D23..D20, D19..D16, ... D3..D0` は
///   `23:20, 19:16, ... 3:0` にそのまま対応する。
///
/// ```wavedrom
/// {
///   signal: [
///     {
///       name: 'Field',
///       wave: 'x3.........45...46...46...46...46...46...46...47...47...47...47...47...47...48...48...48...48...48...48...49...49...49...49...49...49...46...46...46...46...46...46...47...47...47...47...47...47...48...48...48...48...48...48...49...49...49...49...49...49...4x',
///       data: [
///         'SYNC', 'spr',
///         'UserBit', 'spr',
///         'CH0 nibble0', 'spr',
///         'CH0 nibble1', 'spr',
///         'CH0 nibble2', 'spr',
///         'CH0 nibble3', 'spr',
///         'CH0 nibble4', 'spr',
///         'CH0 nibble5', 'spr',
///         'CH1 nibble0', 'spr',
///         'CH1 nibble1', 'spr',
///         'CH1 nibble2', 'spr',
///         'CH1 nibble3', 'spr',
///         'CH1 nibble4', 'spr',
///         'CH1 nibble5', 'spr',
///         'CH2 nibble0', 'spr',
///         'CH2 nibble1', 'spr',
///         'CH2 nibble2', 'spr',
///         'CH2 nibble3', 'spr',
///         'CH2 nibble4', 'spr',
///         'CH2 nibble5', 'spr',
///         'CH3 nibble0', 'spr',
///         'CH3 nibble1', 'spr',
///         'CH3 nibble2', 'spr',
///         'CH3 nibble3', 'spr',
///         'CH3 nibble4', 'spr',
///         'CH3 nibble5', 'spr',
///         'CH4 nibble0', 'spr',
///         'CH4 nibble1', 'spr',
///         'CH4 nibble2', 'spr',
///         'CH4 nibble3', 'spr',
///         'CH4 nibble4', 'spr',
///         'CH4 nibble5', 'spr',
///         'CH5 nibble0', 'spr',
///         'CH5 nibble1', 'spr',
///         'CH5 nibble2', 'spr',
///         'CH5 nibble3', 'spr',
///         'CH5 nibble4', 'spr',
///         'CH5 nibble5', 'spr',
///         'CH6 nibble0', 'spr',
///         'CH6 nibble1', 'spr',
///         'CH6 nibble2', 'spr',
///         'CH6 nibble3', 'spr',
///         'CH6 nibble4', 'spr',
///         'CH6 nibble5', 'spr',
///         'CH7 nibble0', 'spr',
///         'CH7 nibble1', 'spr',
///         'CH7 nibble2', 'spr',
///         'CH7 nibble3', 'spr',
///         'CH7 nibble4', 'spr',
///         'CH7 nibble5', 'spr',
///       ]
///     },
///     {
///       name: 'ADAT in',
///       wave: '10.........1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1====1x',
///       data: [
///         'U3', 'U2', 'U1', 'U0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0',
///         'D23', 'D22', 'D21', 'D20',
///         'D19', 'D18', 'D17', 'D16',
///         'D15', 'D14', 'D13', 'D12',
///         'D11', 'D10', 'D9', 'D8',
///         'D7', 'D6', 'D5', 'D4',
///         'D3', 'D2', 'D1', 'D0'
///       ]
///     }
///   ],
///   head: { text: 'ADAT frame', tick: -1, every: 5 }
/// }
/// ```
///
/// ## 詳細構成（5ビットニブル単位）
///
/// | ビット | 内容 | 説明 |
/// |--------|------|------|
/// | 0-10 | 0000000000 + 1 | SYNC: 10ビットの0（NRZIで無遷移） + separator=1|
/// | 11-15 | U3-U0 + 1 | User nibble: User bits[3:0] + separator|
/// | 16-20 | D23-D20 + 1 | CH0 nibble0: audio[23:20] + separator |
/// | 21-25 | D19-D16 + 1 | CH0 nibble1: audio[19:16] + separator |
/// | 26-30 | D15-D12 + 1 | CH0 nibble2: audio[15:12] + separator |
/// | 31-35 | D11-D8 + 1 | CH0 nibble3: audio[11:8] + separator |
/// | 36-40 | D7-D4 + 1 | CH0 nibble4: audio[7:4] + separator |
/// | 41-45 | D3-D0 + 1 | CH0 nibble5: audio[3:0] + separator |
/// | 46-75 | ... | CH1 (上記と同じ6 nibbles) |
/// | ... | ... | CH2-CH7 (各30ビット) |
///
/// ## セパレーターの役割
/// - 各5ビットニブルの最後に「1」が配置される
/// - これによりNRZIエンコーディングで必ず遷移が発生
/// - 最大5ビット連続で無遷移になるのを防ぎ、同期を維持
///
/// # 使用例
/// ```veryl
/// inst adat: adat_rx (
///     i_clk     : sys_clk_50mhz,
///     i_rst     : reset,
///     i_adat    : toslink_in,
///     o_channels: audio_out,
///     o_frame_clk: frame_clk,
/// );
/// ```
///
/// # タイミング
/// - 推奨クロック: 50MHz
/// - ADAT入力: TOSLINK光→電気変換済み信号
pub module adat_rx (
    /// システムクロック (50MHz推奨)
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// ADAT入力 (光→電気変換済み)
    i_adat: input logic,
    /// ADATフレーム周期のクロック出力（sample rateではない）
    /// 通常は44.1/48kHz。
    /// warning: S/MUX有効時でも44.1kHz/48kHzが出力されることに注意
    o_frame_clk: output logic,
    /// 検出されたS/MUX有効状態 (1: enabled, 0: disabled)
    /// UserBit2による自動判定
    /// warning: UserBitによるS/MUX2とS/MUX4の区別は原理的に不可能なので、あくまでS/MUXが有効or無効のみを示す
    o_smux_active: output logic,
    /// 8チャンネルPCMデータ出力
    o_channels: output logic<24> [8],
    /// データ有効信号
    o_valid: output logic,
    /// 同期ロック状態
    o_locked: output logic,
) {
    // 内部信号
    var adat_edge  : logic    ;
    var synced     : logic    ;
    var edge_time  : logic<12>;
    var sync_detect: logic    ;
    var frame_time : logic<12>;

    var bits      : logic<5> ;
    var bit_count : logic<3> ;
    var bits_valid: logic    ;
    var pcm_data  : logic<24>;
    var channel   : logic<3> ;
    var data_valid: logic    ;

    // 非同期ADAT入力の同期化
    inst u_sync: $std::synchronizer_basic (
        i_clk        ,
        i_rst        ,
        i_d  : i_adat,
        o_d  : synced,
    );

    // エッジ検出
    inst u_edge_detector: $std::edge_detector (
        i_clk               ,
        i_rst               ,
        i_clear  : 0        ,
        i_data   : synced   ,
        o_edge   : adat_edge,
        o_posedge: _        ,
        o_negedge: _        ,
    );

    // タイミング追跡モジュール
    inst u_timing_tracker: timing_tracker (
        i_clk        : i_clk      ,
        i_rst        : i_rst      ,
        i_edge       : adat_edge  ,
        o_edge_time  : edge_time  ,
        o_sync_detect: sync_detect,
        o_frame_time : frame_time ,
    );

    // ビットデコーダ入力を1サイクル遅延
    var edge_delay: logic;
    inst u_delay_edge: $std::delay (
        i_clk            ,
        i_rst            ,
        i_d  : adat_edge ,
        o_d  : edge_delay,
    );

    // ビットデコーダモジュール
    inst u_bit_decoder: bit_decoder (
        i_clk       : i_clk      ,
        i_rst       : i_rst      ,
        i_edge      : edge_delay ,
        i_edge_time : edge_time  ,
        i_frame_time: frame_time ,
        i_sync_mask : sync_detect,
        o_bits      : bits       ,
        o_bit_count : bit_count  ,
        o_valid     : bits_valid ,
    );

    // UserBits出力信号
    var user_bits: logic<4>;

    // フレームパーサモジュール
    inst u_frame_parser: frame_parser (
        i_clk       : i_clk      ,
        i_rst       : i_rst      ,
        i_bits      : bits       ,
        i_bit_count : bit_count  ,
        i_valid     : bits_valid ,
        i_sync      : sync_detect,
        o_user      : user_bits  ,
        o_data      : pcm_data   ,
        o_channel   : channel    ,
        o_data_valid: data_valid ,
    );

    // 出力インターフェースモジュール
    inst u_output_interface: output_interface (
        i_clk        : i_clk        ,
        i_rst        : i_rst        ,
        i_frame_time : frame_time   ,
        i_data       : pcm_data     ,
        i_channel    : channel      ,
        i_data_valid : data_valid   ,
        i_sync       : sync_detect  ,
        i_user_bits  : user_bits    ,
        o_smux_active: o_smux_active,
        o_frame_clk  : o_frame_clk  ,
        o_channels   : o_channels   ,
        o_valid      : o_valid      ,
        o_locked     : o_locked     ,
    );
}

#[test(tb_adat_rx)]
embed (inline) sv{{{
`timescale 1ns / 1ps

// ADATジェネレータモジュール定義
module adat_generator #(
    parameter int CLK_FREQ = 50_000_000,
    parameter int SAMPLE_RATE = 48000,
    parameter int SMUX2_MODE = 0
) (
    input  logic        clk,
    input  logic        rst_n,
    input  logic [23:0] audio_in [0:7],
    input  logic [3:0]  user_in,
    input  logic        start,
    output logic        adat_out,
    output logic        frame_done
);
    localparam int  BIT_RATE = SAMPLE_RATE * 256;
    localparam int  CLOCKS_PER_BIT_INT = CLK_FREQ / BIT_RATE;
    localparam real CLOCKS_PER_BIT_REAL = (1.0 * CLK_FREQ) / BIT_RATE;
    localparam int  CLOCKS_PER_BIT_INIT = $rtoi(CLOCKS_PER_BIT_REAL + 0.5);
    
    typedef enum logic [2:0] {
        IDLE,
        SYNC,
        USER_PRE,
        USER_DATA,
        USER_POST,
        CHANNEL
    } state_t;
    
    state_t state, next_state;
    
    logic [7:0]  bit_counter;
    logic [7:0]  clk_counter;
    logic [7:0]  bit_clocks_target;
    logic [11:0] bit_edge_clocks;
    logic [4:0]  nibble_counter;
    logic [2:0]  channel_counter;
    real         bit_phase_clocks;
    
    logic [255:0] frame_data;
    logic [29:0]  channel_encoded;
    logic         current_bit;
    logic         nrzi_level;
    
    function automatic logic [29:0] encode_24bit(input logic [23:0] data);
        logic [29:0] encoded;
        encoded[29:25] = {data[23:20], 1'b1};
        encoded[24:20] = {data[19:16], 1'b1};
        encoded[19:15] = {data[15:12], 1'b1};
        encoded[14:10] = {data[11:8],  1'b1};
        encoded[9:5]   = {data[7:4],   1'b1};
        encoded[4:0]   = {data[3:0],   1'b1};
        return encoded;
    endfunction
    
    logic [255:0] build_frame;
    logic [3:0] effective_user_in;
    
    always_comb begin
        effective_user_in = user_in;
        if ((SAMPLE_RATE == 44100) && (SMUX2_MODE == 0)) begin
            effective_user_in = {user_in[3], user_in[0], user_in[1], user_in[2]};
        end
        if (SMUX2_MODE == 1) begin
            effective_user_in[1] = 1'b1;
        end
    end
    
    always_comb begin
        build_frame[255:246] = 10'b0000000000;
        build_frame[245] = 1'b1;
        build_frame[244:241] = effective_user_in;
        build_frame[240] = 1'b1;
        build_frame[239:210] = encode_24bit(audio_in[0]);
        build_frame[209:180] = encode_24bit(audio_in[1]);
        build_frame[179:150] = encode_24bit(audio_in[2]);
        build_frame[149:120] = encode_24bit(audio_in[3]);
        build_frame[119:90]  = encode_24bit(audio_in[4]);
        build_frame[89:60]   = encode_24bit(audio_in[5]);
        build_frame[59:30]   = encode_24bit(audio_in[6]);
        build_frame[29:0]    = encode_24bit(audio_in[7]);
    end
    
    assign current_bit = frame_data[255 - bit_counter];
    
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            bit_counter <= 8'd0;
            clk_counter <= 8'd0;
            bit_clocks_target <= CLOCKS_PER_BIT_INIT;
            bit_edge_clocks <= CLOCKS_PER_BIT_INIT;
            bit_phase_clocks <= CLOCKS_PER_BIT_REAL;
            frame_data <= 256'd0;
            nrzi_level <= 1'b0;
            frame_done <= 1'b0;
        end else begin
            frame_done <= 1'b0;
            
            case (state)
                IDLE: begin
                    if (start) begin
                        state <= SYNC;
                        frame_data <= build_frame;
                        bit_counter <= 8'd0;
                        clk_counter <= 8'd0;
                        bit_clocks_target <= CLOCKS_PER_BIT_INIT;
                        bit_edge_clocks <= CLOCKS_PER_BIT_INIT;
                        bit_phase_clocks <= CLOCKS_PER_BIT_REAL;
                    end
                end
                
                SYNC: begin
                    if (clk_counter >= bit_clocks_target - 1) begin
                        clk_counter <= 8'd0;
                        if (current_bit) begin
                            nrzi_level <= ~nrzi_level;
                        end
                        
                        if (bit_counter >= 8'd255) begin
                            state <= IDLE;
                            frame_done <= 1'b1;
                        end else begin
                            int next_edge_clocks;
                            real next_phase_clocks;
                            bit_counter <= bit_counter + 8'd1;
                            next_phase_clocks = bit_phase_clocks + CLOCKS_PER_BIT_REAL;
                            next_edge_clocks = $rtoi(next_phase_clocks + 0.5);
                            bit_phase_clocks <= next_phase_clocks;
                            bit_clocks_target <= next_edge_clocks - bit_edge_clocks;
                            bit_edge_clocks <= next_edge_clocks;
                        end
                    end else begin
                        clk_counter <= clk_counter + 8'd1;
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end
    
    assign adat_out = nrzi_level;
endmodule

module tb_adat_rx;
  // クロック・リセット
  logic           clk;
  logic           rst;

  // DUT信号
  logic           adat_in;
  logic           frame_clk;
  logic           smux_active;
  logic    [23:0] channels  [0:7];
  logic           valid;
  logic           locked;

  // テストデータ
  logic    [23:0] test_audio[0:7];
  logic    [ 3:0] test_user;
  logic           gen_start;
  logic           gen_done;

  // クロック生成 (50MHz)
  initial begin
    clk = 0;
    forever #10 clk = ~clk;
  end

  // ADATジェネレータ (通常モード)
  adat_generator #(
      .CLK_FREQ(50_000_000),
      .SAMPLE_RATE(48000),
      .SMUX2_MODE(0)
  ) u_gen (
      .clk(clk),
      .rst_n(rst),
      .audio_in(test_audio),
      .user_in(test_user),
      .start(gen_start),
      .adat_out(adat_in),
      .frame_done(gen_done)
  );

  // ADATジェネレータ (44.1kHzモード用)
  logic        adat_in_44k;
  logic        gen_done_44k;
  logic        gen_start_44k;
  logic [23:0] test_audio_44k[0:7];
  logic [ 3:0] test_user_44k;

  adat_generator #(
      .CLK_FREQ(50_000_000),
      .SAMPLE_RATE(44100),
      .SMUX2_MODE(0)
  ) u_gen_44k (
      .clk(clk),
      .rst_n(rst),
      .audio_in(test_audio_44k),
      .user_in(test_user_44k),
      .start(gen_start_44k),
      .adat_out(adat_in_44k),
      .frame_done(gen_done_44k)
  );

  // ADATジェネレータ (S/MUX2モード用 - 96kHz)
  logic        adat_in_smux2;
  logic        gen_done_smux2;
  logic        gen_start_smux2;
  logic [23:0] test_audio_smux2[0:7];
  logic [ 3:0] test_user_smux2;

  adat_generator #(
      .CLK_FREQ(50_000_000),
      .SAMPLE_RATE(48000),
      .SMUX2_MODE(1)
  ) u_gen_smux2 (
      .clk(clk),
      .rst_n(rst),
      .audio_in(test_audio_smux2),
      .user_in(test_user_smux2),
      .start(gen_start_smux2),
      .adat_out(adat_in_smux2),
      .frame_done(gen_done_smux2)
  );

  // ADATジェネレータ (S/MUX2モード用 - 88.2kHz)
  logic        adat_in_smux2_88k;
  logic        gen_done_smux2_88k;
  logic        gen_start_smux2_88k;
  logic [23:0] test_audio_smux2_88k[0:7];
  logic [ 3:0] test_user_smux2_88k;

  adat_generator #(
      .CLK_FREQ(50_000_000),
      .SAMPLE_RATE(44100),
      .SMUX2_MODE(1)
  ) u_gen_smux2_88k (
      .clk(clk),
      .rst_n(rst),
      .audio_in(test_audio_smux2_88k),
      .user_in(test_user_smux2_88k),
      .start(gen_start_smux2_88k),
      .adat_out(adat_in_smux2_88k),
      .frame_done(gen_done_smux2_88k)
  );

  // Multiplexed ADAT input (select between normal, 44.1kHz, S/MUX2 96kHz, and S/MUX2 88.2kHz generators)
  logic adat_in_muxed;
  assign adat_in_muxed = gen_start_smux2_88k ? adat_in_smux2_88k : (gen_start_smux2 ? adat_in_smux2 : (gen_start_44k ? adat_in_44k : adat_in));

  // DUT内部プローブ(デバッグ用)
  logic        dbg_adat_edge;
  logic        dbg_adat_synced;
  logic [11:0] dbg_frame_time;
  logic        dbg_sync_detect;
  logic [ 4:0] dbg_bits;
  logic [ 2:0] dbg_bit_count;
  logic        dbg_bits_valid;
  logic [29:0] dbg_shift_reg;
  logic [ 7:0] dbg_bit_counter;
  logic [ 2:0] dbg_channel;
  logic        dbg_data_valid;
  logic [ 3:0] dbg_frame_cnt;

  adat_rx_adat_rx u_dut (
      .i_clk(clk),
      .i_rst(rst),
      .i_adat(adat_in_muxed),
      .o_frame_clk(frame_clk),
      .o_smux_active(smux_active),
      .o_channels(channels),
      .o_valid(valid),
      .o_locked(locked)
  );

  assign dbg_adat_edge = u_dut.adat_edge;
  assign dbg_adat_synced = u_dut.synced;
  assign dbg_frame_time = u_dut.frame_time;
  assign dbg_sync_detect = u_dut.sync_detect;
  assign dbg_bits = u_dut.bits;
  assign dbg_bit_count = u_dut.bit_count;
  assign dbg_bits_valid = u_dut.bits_valid;
  assign dbg_shift_reg = u_dut.u_frame_parser.shift_reg;
  assign dbg_bit_counter = u_dut.u_frame_parser.bit_counter;
  assign dbg_channel = u_dut.channel;
  assign dbg_data_valid = u_dut.data_valid;
  assign dbg_frame_cnt = u_dut.u_output_interface.frame_cnt;

  // Metrics collection
  /* verilator lint_off BLKSEQ */
  always @(posedge clk) begin
    if (dbg_bits_valid) begin
      bits_valid_count++;
      if (dbg_bit_count >= 1 && dbg_bit_count <= 5) bit_count_hist[dbg_bit_count]++;
    end
    if (dbg_data_valid) begin
      if (dbg_channel <= 7) boundary_pass[dbg_channel]++;
    end
  end
  /* verilator lint_on BLKSEQ */

  int frame_count;

  // Metrics counters
  int bits_valid_count;
  int bit_count_hist[0:5];  // index 0 unused, 1-5 for bit counts
  int boundary_pass[0:7];  // boundary crossing counts for each channel

  task automatic reset_dut();
    begin
      rst = 0;
      #100;
      rst = 1;
      #100;
    end
  endtask

  task automatic send_frames(input int frames, ref logic done_sig, input string label);
    begin
      for (int f = 0; f < frames; f++) begin
        @(posedge done_sig);
        #10;
        if (label != "") begin
          $display("%s Frame %0d completed", label, f + 1);
        end else begin
          $display("Frame %0d completed", f + 1);
        end
      end
    end
  endtask

  task automatic wait_for_valid(input string tag);
    logic got_valid_local;
    begin
      got_valid_local = 1'b0;
      fork
        begin
          @(posedge valid);
          got_valid_local = 1'b1;
        end
        begin
          #200_000;
        end
      join_any
      disable fork;

      if (!got_valid_local) begin
        $error("%sFAIL: Timeout waiting for valid", tag);
        $finish;
      end
      #10;
    end
  endtask

  task automatic compare_channels(input string tag, input logic [23:0] expected[0:7]);
    begin
      for (int i = 0; i < 8; i++) begin
        if (channels[i] !== expected[i]) begin
          $error("%sChannel %0d: FAIL - Expected: %h, Got: %h", tag, i, expected[i], channels[i]);
        end
      end
    end
  endtask


  initial begin
    $display("Clock: 50MHz, Sample Rate: 48kHz");
    $display("=== ADAT Receiver Test (Strict Comparison) ===");

    // 初期化 (DUT: アクティブローリセット)
    rst = 0;
    gen_start = 0;
    frame_count = 0;

    // Metrics initialization
    bits_valid_count = 0;
    for (int i = 0; i <= 5; i++) bit_count_hist[i] = 0;
    for (int i = 0; i <= 7; i++) boundary_pass[i] = 0;

    // テストデータ設定
    test_user = 4'hA;
    test_audio[0] = 24'h123456;
    test_audio[1] = 24'h789ABC;
    test_audio[2] = 24'hDEF012;
    test_audio[3] = 24'h345678;
    test_audio[4] = 24'h9ABCDE;
    test_audio[5] = 24'hF01234;
    test_audio[6] = 24'h567890;
    test_audio[7] = 24'hABCDEF;

    // リセット解除 (アクティブローなので1にする)
    reset_dut();

    // 連続フレーム送信を開始（startを保持すると連続生成される）
    gen_start = 1;

    $display("\n--- Monitoring first frame ---");
    fork
      begin
        int edge_count = 0;
        int timeout = 0;
        while (edge_count < 100 && timeout < 50000) begin
          @(posedge clk);
          timeout++;
          if (dbg_adat_edge) begin
            edge_count++;
            if (edge_count <= 5) begin
              $display("Edge %0d detected at time %0t: adat_in=%b, synced=%b", edge_count, $time,
                       adat_in, dbg_adat_synced);
            end
          end
        end
        $display("Total edges detected: %0d", edge_count);
      end
    join_none

    // フレーム完了を待つ（メインスレッドで実行）
    send_frames(10, gen_done, "");
    frame_count = 10;

    // エッジモニタを停止
    disable fork;

    // ロック確認
    #100;

    $display("\n=== Metrics ===");
    $display("bits_valid_count: %0d", bits_valid_count);
    $display("bit_count_hist: 1bit=%0d, 2bit=%0d, 3bit=%0d, 4bit=%0d, 5bit=%0d", bit_count_hist[1],
             bit_count_hist[2], bit_count_hist[3], bit_count_hist[4], bit_count_hist[5]);
    $display(
        "boundary_pass: ch0=%0d, ch1=%0d, ch2=%0d, ch3=%0d, ch4=%0d, ch5=%0d, ch6=%0d, ch7=%0d",
        boundary_pass[0], boundary_pass[1], boundary_pass[2], boundary_pass[3], boundary_pass[4],
        boundary_pass[5], boundary_pass[6], boundary_pass[7]);

    $display("\n=== Debug Info ===");
    $display("adat_in: %b", adat_in);
    $display("ADAT edge: %b, Synced: %b", dbg_adat_edge, dbg_adat_synced);
    $display("Frame time: %0d (expected ~2083)", dbg_frame_time);
    $display("Sync detect: %b", dbg_sync_detect);
    $display("Bits valid: %b, Bit count: %0d, Bits: %b", dbg_bits_valid, dbg_bit_count, dbg_bits);
    $display("Bit counter: %0d, Shift reg: %h", dbg_bit_counter, dbg_shift_reg);
    $display("Data valid: %b, Channel: %0d", dbg_data_valid, dbg_channel);
    $display("Frame cnt: %0d", dbg_frame_cnt);
    $display("Locked: %b", locked);

    if (!locked) begin
      $error("FAIL: Receiver not locked");
      $finish;
    end else begin
      $display("PASS: Receiver locked");
    end

    $display("\nStarting strict data comparison...");

    repeat (5) begin
      wait_for_valid("");
      compare_channels("", test_audio);

      #100;
    end

    $display("\n=== Test Results ===");
    $display("Frames sent: %0d", frame_count);
    $display("*** TEST SECTION DONE ***");

    // ==================== 44.1kHz TEST ====================
    $display("\n=== 44.1kHz Test ===");
    $display("Clock: 50MHz, Sample Rate: 44.1kHz");

    // テストデータ設定
    test_user_44k = 4'hB;
    test_audio_44k[0] = 24'h441100;
    test_audio_44k[1] = 24'h441111;
    test_audio_44k[2] = 24'h441122;
    test_audio_44k[3] = 24'h441133;
    test_audio_44k[4] = 24'h441144;
    test_audio_44k[5] = 24'h441155;
    test_audio_44k[6] = 24'h441166;
    test_audio_44k[7] = 24'h441177;

    // リセット
    rst = 0;
    gen_start = 0;
    gen_start_44k = 0;
    gen_start_smux2 = 0;
    frame_count = 0;
    reset_dut();

    // 44.1kHzフレーム送信開始
    gen_start_44k = 1;

    // フレーム送信
    send_frames(10, gen_done_44k, "44.1kHz");
    frame_count = 10;

    // ロック確認
    #100;

    $display("\n=== 44.1kHz Debug Info ===");
    $display("Frame time: %0d (expected ~2268 for 44.1kHz)", dbg_frame_time);
    $display("Locked: %b", locked);

    if (!locked) begin
      $error("44.1kHz FAIL: Receiver not locked");
      $finish;
    end else begin
      $display("44.1kHz PASS: Receiver locked");
    end

    $display("\n44.1kHz: Starting strict data comparison...");

    repeat (5) begin
      wait_for_valid("44.1kHz ");
      compare_channels("44.1kHz ", test_audio_44k);

      #100;
    end

    $display("\n=== 44.1kHz Test Results ===");
    $display("Frames sent: %0d", frame_count);
    $display("*** 44.1kHz TEST SECTION DONE ***");

    // ==================== S/MUX2 TEST ====================
    $display("\n=== S/MUX2 Test (96kHz 4ch mode) ===");

    // テストデータ設定 (8チャンネル分のデータを用意)
    test_user_smux2 = 4'b0000;  // user_in[2]は自動的に1になる
    test_audio_smux2[0] = 24'hAA0000;
    test_audio_smux2[1] = 24'hAA1111;
    test_audio_smux2[2] = 24'hBB0000;
    test_audio_smux2[3] = 24'hBB1111;
    test_audio_smux2[4] = 24'hCC0000;
    test_audio_smux2[5] = 24'hCC1111;
    test_audio_smux2[6] = 24'hDD0000;
    test_audio_smux2[7] = 24'hDD1111;

    // リセット
    rst = 0;
    gen_start = 0;
    gen_start_smux2 = 0;
    reset_dut();

    // S/MUX2フレーム送信開始
    gen_start_smux2 = 1;

    // 10フレーム送信
    send_frames(10, gen_done_smux2, "");

    // ロック確認
    #100;
    if (!locked) begin
      $error("S/MUX2 FAIL: Receiver not locked");
    end

    // S/MUX有効期待値チェック
    if (smux_active != 1'b1) begin
      $error("S/MUX2 FAIL: smux_active is not 1");
    end

    // データ整合性チェック (物理チャンネル0-7がそのまま出力されることを確認)
    wait_for_valid("");
    compare_channels("  ", test_audio_smux2);

    // ==================== 88.2kHz S/MUX2 TEST ====================
    $display("\n=== 88.2kHz S/MUX2 Test (88.2kHz 4ch mode) ===");

    // テストデータ設定 (8チャンネル分のデータを用意)
    test_user_smux2_88k = 4'b0000;  // user_in[2]は自動的に1になる
    test_audio_smux2_88k[0] = 24'h882000;
    test_audio_smux2_88k[1] = 24'h882111;
    test_audio_smux2_88k[2] = 24'h882200;
    test_audio_smux2_88k[3] = 24'h882311;
    test_audio_smux2_88k[4] = 24'h882400;
    test_audio_smux2_88k[5] = 24'h882511;
    test_audio_smux2_88k[6] = 24'h882600;
    test_audio_smux2_88k[7] = 24'h882711;

    // リセット
    rst = 0;
    gen_start = 0;
    gen_start_44k = 0;
    gen_start_smux2 = 0;
    gen_start_smux2_88k = 0;
    reset_dut();

    // 88.2kHz S/MUX2フレーム送信開始
    gen_start_smux2_88k = 1;

    // 10フレーム送信
    send_frames(10, gen_done_smux2_88k, "");

    // ロック確認
    #100;
    if (!locked) begin
      $error("88.2kHz S/MUX2 FAIL: Receiver not locked");
    end

    // S/MUX有効期待値チェック
    if (smux_active != 1'b1) begin
      $error("88.2kHz S/MUX2 FAIL: smux_active is not 1");
    end

    // データ整合性チェック (物理チャンネル0-7がそのまま出力されることを確認)
    wait_for_valid("88.2kHz ");
    compare_channels("  88.2kHz ", test_audio_smux2_88k);

    #1000;
    $finish;
  end

endmodule
}}}
