import adat_pkg::*;

/// 出力インターフェース
///
/// S/MUX対応、サンプルレート自動検出、ワードクロック生成を行う。
///
/// # ワードクロック
/// フレーム周期の約50%デューティで出力
module output_interface (
    /// システムクロック
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// フレーム時間
    i_frame_time: input logic<12>,
    /// PCMデータ入力
    i_data: input logic<24>,
    /// チャンネル番号
    i_channel: input logic<3>,
    /// データ有効
    i_data_valid: input logic,
    /// 同期マスク
    i_sync: input logic,
    /// ユーザービット入力
    i_user_bits: input logic<4>,
    /// 検出されたS/MUXモード
    o_smux_mode: output SmuxMode,
    /// ワードクロック出力
    o_word_clk: output logic,
    /// 8チャンネルPCMデータ出力
    o_channels: output logic<24> [8],
    /// 全チャンネルデータ有効
    o_valid: output logic,
    /// 同期ロック状態
    o_locked: output logic,
    /// 有効なチャンネル数
    o_valid_channels: output logic<4>,
) {
    // S/MUXモードレジスタ
    var smux_mode: SmuxMode;
    // ワードクロックカウンタ
    var word_clk_cnt: logic<12>;
    // ワードクロック出力
    var word_clk: logic;
    // チャンネルデータバッファ
    var channels: logic<24> [8];
    // 出力有効
    var valid_out: logic;
    // ロック状態
    var locked: logic;
    // フレームカウンタ（ロック検出用）
    var frame_cnt: logic<4>;
    // S/MUX2モード検出
    var smux2_mode: logic;
    // 出力フェーズ（S/MUX2用）
    var output_phase: logic;

    // S/MUX2モード検出 (ADAT User Bit 2 → i_user_bits[1])
    // TODO UserBit2が本当にi_user_bits[1]か確認
    assign smux2_mode = i_user_bits[1];

    // S/MUXモード出力（S/MUX2検出結果を反映）
    always_comb {
        if smux2_mode {
            smux_mode = SmuxMode::Smux2;
        } else {
            smux_mode = SmuxMode::Standard;
        }
    }

    assign o_smux_mode = smux_mode;
    assign o_word_clk  = word_clk;
    assign o_valid     = valid_out;
    assign o_locked    = locked;

    always_comb {
        if smux2_mode {
            o_valid_channels = 4'd4;
        } else {
            o_valid_channels = 4'd8;
        }
    }

    // チャンネル出力割り当て
    for i in 0..8 :g_ch_out {
        assign o_channels[i] = channels[i];
    }

    // ロック検出
    // 数フレーム連続で同期が取れたらロック
    always_ff (i_clk, i_rst) {
        if_reset {
            frame_cnt = 4'd0;
            locked    = 1'b0;
        } else if i_data_valid && i_channel == 3'd7 {
            // 最後のチャンネル受信でカウントアップ
            if frame_cnt <: 4'd15 {
                frame_cnt = frame_cnt + 4'd1;
            }
            if frame_cnt >= 4'd4 {
                locked = 1'b1;
            }
        }
    }

    // ワードクロック生成
    // フレーム時間の約50%デューティ
    always_ff (i_clk, i_rst) {
        if_reset {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b0;
        } else if !i_sync {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b1;
        } else {
            word_clk_cnt = word_clk_cnt + 12'd1;
            if word_clk_cnt >: (i_frame_time >> 1) {
                word_clk = 1'b0;
            } else {
                word_clk = 1'b1;
            }
        }
    }

    // チャンネルデータ格納
    always_ff (i_clk, i_rst) {
        if_reset {
            channels[0]  = 24'd0;
            channels[1]  = 24'd0;
            channels[2]  = 24'd0;
            channels[3]  = 24'd0;
            channels[4]  = 24'd0;
            channels[5]  = 24'd0;
            channels[6]  = 24'd0;
            channels[7]  = 24'd0;
            valid_out    = 1'b0;
            output_phase = 1'b0;
        } else {
            // S/MUX2モードで2回目のo_validを出力する必要がある場合
            if smux2_mode && output_phase == 1'b1 {
                // 2回目のo_valid出力
                valid_out    = 1'b1;
                output_phase = 1'b0;
            } else if i_data_valid {
                // チャンネルデータを格納
                channels[i_channel] = i_data;
                // 最後のチャンネル(7)受信で出力有効
                if i_channel == 3'd7 {
                    if smux2_mode {
                        // S/MUX2モード: 1回目のo_valid出力
                        valid_out    = 1'b1;
                        output_phase = 1'b1;
                    } else {
                        // 通常モード: o_valid出力
                        valid_out    = 1'b1;
                        output_phase = 1'b0;
                    }
                } else {
                    valid_out = 1'b0;
                }
            } else {
                valid_out = 1'b0;
            }
        }
    }
}

#[test(tb_output_interface)]
embed (inline) sv{{{
`timescale 1ns / 1ps

module tb_output_interface;
  import adat_rx_adat_pkg::*;

  typedef adat_rx_adat_pkg::SmuxMode SmuxMode;

  logic clk;
  logic rst;
  logic [11:0] frame_time;
  logic [23:0] data;
  logic [2:0] channel;
  logic data_valid;
  logic sync;
  logic [3:0] user_bits;
  SmuxMode smux_mode;
  logic word_clk;
  logic [23:0] channels[0:7];
  logic valid;
  logic locked;
  logic [3:0] valid_channels;

  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  adat_rx_output_interface u_dut (
      .i_clk(clk),
      .i_rst(rst),
      .i_frame_time(frame_time),
      .i_data(data),
      .i_channel(channel),
      .i_data_valid(data_valid),
      .i_sync(sync),
      .i_user_bits(user_bits),
      .o_smux_mode(smux_mode),
      .o_word_clk(word_clk),
      .o_channels(channels),
      .o_valid(valid),
      .o_locked(locked),
      .o_valid_channels(valid_channels)
  );

  task send_frame(input int frames);
    int f;
    int ch;
    begin
      for (f = 0; f < frames; f++) begin
        for (ch = 0; ch < 8; ch++) begin
          channel = ch[2:0];
          data = {8'hAA, 8'h00, ch[7:0]};
          data_valid = 1'b1;
          @(posedge clk);
          if (channel == 3'd7 && !valid) begin
            $error("FAIL: valid not asserted on ch7");
            pass = 0;
          end
        end
        data_valid = 1'b0;
        @(posedge clk);
      end
    end
  endtask

  int pass;

  initial begin
    pass = 1;
    rst = 1'b0;
    frame_time = 12'd2048;
    data = 24'd0;
    channel = 3'd0;
    data_valid = 1'b0;
    sync = 1'b1;
    user_bits = 4'b0000;  // Normal mode (S/MUX2 bit=0)
    repeat (2) @(posedge clk);
    rst = 1'b1;
    repeat (2) @(posedge clk);

    // Test 1: Normal 48kHz mode
    $display("=== Test 1: Normal 48kHz Mode ===");
    send_frame(5);

    if (!locked) begin
      $error("FAIL: locked not asserted");
      pass = 0;
    end
    if (smux_mode !== SmuxMode_Standard) begin
      $error("FAIL: smux_mode not Standard");
      pass = 0;
    end
    if (valid_channels !== 4'd8) begin
      $error("FAIL: valid_channels should be 8 in normal mode, got %d", valid_channels);
      pass = 0;
    end

    // Test 2: S/MUX2 mode
    $display("=== Test 2: S/MUX2 Mode ===");
    rst = 1'b0;
    user_bits = 4'b0010;  // S/MUX2 mode (bit[1]=1)
    repeat (2) @(posedge clk);
    rst = 1'b1;
    repeat (2) @(posedge clk);

    send_frame(5);

    if (!locked) begin
      $error("FAIL: locked not asserted in S/MUX2");
      pass = 0;
    end
    if (smux_mode !== SmuxMode_Smux2) begin
      $error("FAIL: smux_mode should be SmuxMode_Smux2 in S/MUX2, got %d", smux_mode);
      pass = 0;
    end
    if (valid_channels !== 4'd4) begin
      $error("FAIL: valid_channels should be 4 in S/MUX2 mode, got %d", valid_channels);
      pass = 0;
    end

    if (pass) begin
      $display("*** TEST PASSED ***");
    end else begin
      $error("*** TEST FAILED ***");
    end

    #20;
    $finish;
  end
endmodule
}}}
