import adat_pkg::SmuxMode;

/// 出力インターフェース
///
/// S/MUX対応、サンプルレート自動検出、ワードクロック生成を行う。
///
/// # サンプルレート対応
/// - 44.1kHz / 48kHz: 8チャンネル出力
/// - 88.2kHz / 96kHz: 4チャンネル出力 (S/MUX2 - Ch0+Ch4, Ch1+Ch5, Ch2+Ch6, Ch3+Ch7)
/// - 176.4kHz / 192kHz: 2チャンネル出力 (S/MUX4 - Ch0+Ch2+Ch4+Ch6, Ch1+Ch3+Ch5+Ch7)
///
/// # ワードクロック
/// フレーム周期の約50%デューティで出力
///
/// ```wavedrom
/// {signal: [
///   {name: 'i_clk', wave: 'p.................................'},
///   {name: 'i_sync', wave: '0.................................'},
///   {name: 'i_data_valid', wave: '0...10...10...10...10...10...10...10...10..'},
///   {name: 'i_channel', wave: 'x...2....3....4....5....6....7....0....1..', data: ['0', '1', '2', '3', '4', '5', '6', '7', '0']},
///   {name: 'word_clk_cnt', wave: 'x2...2....2....2....2....2....2....2....2.', data: ['0', '~260', '0', '~260', '0', '~260', '0', '~260', '0']},
///   {name: 'o_word_clk', wave: '1....0.........1.........0.........1.....'},
///   {name: 'o_valid', wave: '0...............................10.........'},
///   {name: 'frame_cnt', wave: 'x2..............................2....3...', data: ['0', '1', '2']},
///   {name: 'o_locked', wave: '0......................................1.'}
/// ],
/// config: {hscale: 2},
/// head: {text: 'Word Clock Generation'}}
/// ```
pub module output_interface (
    /// システムクロック
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// フレーム時間
    i_frame_time: input logic<12>,
    /// PCMデータ入力
    i_data: input logic<24>,
    /// チャンネル番号
    i_channel: input logic<3>,
    /// データ有効
    i_data_valid: input logic,
    /// 同期マスク
    i_sync: input logic,
    /// ユーザービット入力
    i_user_bits: input logic<4>,
    /// 検出されたS/MUXモード
    o_smux_mode: output SmuxMode,
    /// ワードクロック出力
    o_word_clk: output logic,
    /// 8チャンネルPCMデータ出力
    o_channels: output logic<24> [8],
    /// 全チャンネルデータ有効
    o_valid: output logic,
    /// 同期ロック状態
    o_locked: output logic,
    /// 有効なチャンネル数
    o_valid_channels: output logic<4>,
) {
    // S/MUXモードレジスタ
    var smux_mode: SmuxMode;
    // ワードクロックカウンタ
    var word_clk_cnt: logic<12>;
    // ワードクロック出力
    var word_clk: logic;
    // チャンネルデータバッファ
    var channels: logic<24> [8];
    // 出力有効
    var valid_out: logic;
    // ロック状態
    var locked: logic;
    // フレームカウンタ（ロック検出用）
    var frame_cnt: logic<4>;
    // S/MUX2モード検出
    var smux2_mode: logic;
    // 出力フェーズ（S/MUX2用）
    var output_phase: logic;

    // S/MUX2モード検出 (ADAT User Bit 2 → i_user_bits[1])
    assign smux2_mode = i_user_bits[1];

    // S/MUXモード出力（S/MUX2検出結果を反映）
    always_comb {
        if smux2_mode {
            smux_mode = SmuxMode::Smux2;
        } else {
            smux_mode = SmuxMode::Standard;
        }
    }

    assign o_smux_mode = smux_mode;
    assign o_word_clk  = word_clk;
    assign o_valid     = valid_out;
    assign o_locked    = locked;

    always_comb {
        if smux2_mode {
            o_valid_channels = 4'd4;
        } else {
            o_valid_channels = 4'd8;
        }
    }

    // チャンネル出力割り当て
    for i in 0..8 :g_ch_out {
        assign o_channels[i] = channels[i];
    }

    // ロック検出
    // 数フレーム連続で同期が取れたらロック
    always_ff (i_clk, i_rst) {
        if_reset {
            frame_cnt = 4'd0;
            locked    = 1'b0;
        } else if i_data_valid && i_channel == 3'd7 {
            // 最後のチャンネル受信でカウントアップ
            if frame_cnt <: 4'd15 {
                frame_cnt = frame_cnt + 4'd1;
            }
            if frame_cnt >= 4'd4 {
                locked = 1'b1;
            }
        }
    }

    // ワードクロック生成
    // フレーム時間の約50%デューティ
    always_ff (i_clk, i_rst) {
        if_reset {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b0;
        } else if !i_sync {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b1;
        } else {
            word_clk_cnt = word_clk_cnt + 12'd1;
            if word_clk_cnt >: (i_frame_time >> 1) {
                word_clk = 1'b0;
            } else {
                word_clk = 1'b1;
            }
        }
    }

    // チャンネルデータ格納
    always_ff (i_clk, i_rst) {
        if_reset {
            channels[0]  = 24'd0;
            channels[1]  = 24'd0;
            channels[2]  = 24'd0;
            channels[3]  = 24'd0;
            channels[4]  = 24'd0;
            channels[5]  = 24'd0;
            channels[6]  = 24'd0;
            channels[7]  = 24'd0;
            valid_out    = 1'b0;
            output_phase = 1'b0;
        } else {
            // S/MUX2モードで2回目のo_validを出力する必要がある場合
            if smux2_mode && output_phase == 1'b1 {
                // 2回目のo_valid出力
                valid_out    = 1'b1;
                output_phase = 1'b0;
            } else if i_data_valid {
                // チャンネルデータを格納
                channels[i_channel] = i_data;
                // 最後のチャンネル(7)受信で出力有効
                if i_channel == 3'd7 {
                    if smux2_mode {
                        // S/MUX2モード: 1回目のo_valid出力
                        valid_out    = 1'b1;
                        output_phase = 1'b1;
                    } else {
                        // 通常モード: o_valid出力
                        valid_out    = 1'b1;
                        output_phase = 1'b0;
                    }
                } else {
                    valid_out = 1'b0;
                }
            } else {
                valid_out = 1'b0;
            }
        }
    }
}
