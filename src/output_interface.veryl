/// 出力インターフェース
///
/// S/MUX対応、サンプルレート自動検出、フレームクロック生成を行う。
///
/// # フレームクロック
/// ADATフレーム周期のクロック（サンプルクロックではない）
/// 通常は44.1/48kHz、S/MUX有効時のサンプルレートはこの2倍または4倍
/// フレーム周期の約50%デューティで出力
module output_interface (
    /// システムクロック
    i_clk: input clock,
    /// アクティブハイリセット
    i_rst: input reset,
    /// フレーム時間
    i_frame_time: input logic<12>,
    /// PCMデータ入力
    i_data: input logic<24>,
    /// チャンネル番号
    i_channel: input logic<3>,
    /// データ有効
    i_data_valid: input logic,
    /// 同期マスク
    i_sync: input logic,
    /// ユーザービット入力
    i_user_bits: input logic<4>,
    /// 検出されたS/MUX有効状態 (1: enabled, 0: disabled)
    o_smux_active: output logic,
    /// ADATフレーム周期のクロック出力（サンプルクロックではない）
    o_frame_clk: output logic,
    /// 8チャンネルPCMデータ出力
    o_channels: output logic<24> [8],
    /// 全チャンネルデータ有効
    o_valid: output logic,
    /// 同期ロック状態
    o_locked: output logic,
) {
    // ワードクロックカウンタ
    var word_clk_cnt: logic<12>;
    // ワードクロック出力
    var word_clk: logic;
    // チャンネルデータバッファ
    var channels: logic<24> [8];
    // 出力有効
    var valid_out: logic;
    // ロック状態
    var locked: logic;
    // フレームカウンタ（ロック検出用）
    var frame_cnt: logic<4>;
    // UserBit由来のS/MUX有効フラグ
    var smux_active: logic;

    // S/MUX有効判定 (ADAT User Bit 2 → i_user_bits[1])
    // Note: ここからS/MUX2とS/MUX4の区別はできない
    assign smux_active = i_user_bits[1];

    assign o_smux_active = smux_active;
    assign o_frame_clk   = word_clk;
    assign o_valid       = valid_out;
    assign o_locked      = locked;

    // チャンネル出力割り当て
    for i in 0..8 :g_ch_out {
        assign o_channels[i] = channels[i];
    }

    // ロック検出
    // 数フレーム連続で同期が取れたらロック
    always_ff (i_clk, i_rst) {
        if_reset {
            frame_cnt = 4'd0;
            locked    = 1'b0;
        } else if i_data_valid && i_channel == 3'd7 {
            // 最後のチャンネル受信でカウントアップ
            if frame_cnt <: 4'd15 {
                frame_cnt = frame_cnt + 4'd1;
            }
            if frame_cnt >= 4'd4 {
                locked = 1'b1;
            }
        }
    }

    // ワードクロック生成
    // フレーム時間の約50%デューティ
    always_ff (i_clk, i_rst) {
        if_reset {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b0;
        } else if !i_sync {
            word_clk_cnt = 12'd0;
            word_clk     = 1'b1;
        } else {
            word_clk_cnt = word_clk_cnt + 12'd1;
            if word_clk_cnt >: (i_frame_time >> 1) {
                word_clk = 1'b0;
            } else {
                word_clk = 1'b1;
            }
        }
    }

    // チャンネルデータ格納
    always_ff (i_clk, i_rst) {
        if_reset {
            channels[0] = 24'd0;
            channels[1] = 24'd0;
            channels[2] = 24'd0;
            channels[3] = 24'd0;
            channels[4] = 24'd0;
            channels[5] = 24'd0;
            channels[6] = 24'd0;
            channels[7] = 24'd0;
            valid_out   = 1'b0;
        } else if i_data_valid {
            // チャンネルデータを格納
            channels[i_channel] = i_data;
            // 最後のチャンネル(7)受信で1回だけ出力有効
            if i_channel == 3'd7 {
                valid_out = 1'b1;
            } else {
                valid_out = 1'b0;
            }
        } else {
            valid_out = 1'b0;
        }
    }
}

#[test(tb_output_interface)]
embed (inline) sv{{{
`timescale 1ns / 1ps

module tb_output_interface;
  logic clk;
  logic rst;
  logic [11:0] frame_time;
  logic [23:0] data;
  logic [2:0] channel;
  logic data_valid;
  logic sync;
  logic [3:0] user_bits;
  logic smux_active;
  logic frame_clk;
  logic [23:0] channels[0:7];
  logic valid;
  logic locked;

  initial begin
    clk = 0;
    forever #5 clk = ~clk;
  end

  adat_rx_output_interface u_dut (
      .i_clk(clk),
      .i_rst(rst),
      .i_frame_time(frame_time),
      .i_data(data),
      .i_channel(channel),
      .i_data_valid(data_valid),
      .i_sync(sync),
      .i_user_bits(user_bits),
      .o_smux_active(smux_active),
      .o_frame_clk(frame_clk),
      .o_channels(channels),
      .o_valid(valid),
      .o_locked(locked)
  );

  task send_frame(input int frames);
    int f;
    int ch;
    begin
      for (f = 0; f < frames; f++) begin
        for (ch = 0; ch < 8; ch++) begin
          channel = ch[2:0];
          data = {8'hAA, 8'h00, ch[7:0]};
          data_valid = 1'b1;
          @(posedge clk);
          if (channel == 3'd7 && !valid) begin
            $error("FAIL: valid not asserted on ch7");
            pass = 0;
          end
        end
        data_valid = 1'b0;
        @(posedge clk);
      end
    end
  endtask

  int pass;

  initial begin
    pass = 1;
    rst = 1'b0;
    frame_time = 12'd2048;
    data = 24'd0;
    channel = 3'd0;
    data_valid = 1'b0;
    sync = 1'b1;
    user_bits = 4'b0000;  // S/MUX disabled (bit[1]=0)
    repeat (2) @(posedge clk);
    rst = 1'b1;
    repeat (2) @(posedge clk);

    // Test 1: Normal 48kHz mode
    $display("=== Test 1: Normal 48kHz Mode ===");
    send_frame(5);

    if (!locked) begin
      $error("FAIL: locked not asserted");
      pass = 0;
    end
    if (smux_active !== 1'b0) begin
      $error("FAIL: smux_active should be 0");
      pass = 0;
    end

    // Test 2: S/MUX enabled
    $display("=== Test 2: S/MUX Enabled ===");
    rst = 1'b0;
    user_bits = 4'b0010;  // S/MUX enabled (bit[1]=1)
    repeat (2) @(posedge clk);
    rst = 1'b1;
    repeat (2) @(posedge clk);

    send_frame(5);

    if (!locked) begin
      $error("FAIL: locked not asserted in S/MUX enabled");
      pass = 0;
    end
    if (smux_active !== 1'b1) begin
      $error("FAIL: smux_active should be 1 when S/MUX bit is set, got %b", smux_active);
      pass = 0;
    end
    if (pass) begin
      $display("*** TEST PASSED ***");
    end else begin
      $error("*** TEST FAILED ***");
    end

    #20;
    $finish;
  end
endmodule
}}}
